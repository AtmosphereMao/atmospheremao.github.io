{"meta":{"title":"AtmosphereMao Blog","subtitle":"","description":"","author":"Atmospheremao","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-12-14T15:54:43.320Z","updated":"2019-12-14T15:54:43.320Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一名软件技术专业的大学生，爱编程、爱游戏、爱音乐、爱电影。 关于我 年级：大二 专业：软件技术 技术：PHP、Python、Java 热爱：Laravel"}],"posts":[{"title":"SZPTEhall防疫期间学生每日信息线上填报爬虫","slug":"SZPTEhall防疫期间学生每日信息线上填报爬虫","date":"2020-02-25T14:52:40.530Z","updated":"2020-02-25T17:36:45.569Z","comments":true,"path":"2020/02/25/SZPTEhall防疫期间学生每日信息线上填报爬虫/","link":"","permalink":"http://yoursite.com/2020/02/25/SZPTEhall%E9%98%B2%E7%96%AB%E6%9C%9F%E9%97%B4%E5%AD%A6%E7%94%9F%E6%AF%8F%E6%97%A5%E4%BF%A1%E6%81%AF%E7%BA%BF%E4%B8%8A%E5%A1%AB%E6%8A%A5%E7%88%AC%E8%99%AB/","excerpt":"","text":"SZPT.Ehall 防疫期间学生每日信息线上填报爬虫源码 关于根据填写用户名与密码，模拟登录https://ehall.szpt.edu.cn/，并进入填报信息处爬取昨日提交的信息，并发送为今日的填报信息。 外部库urllib3，crypto，schedule 逻辑解析Authserver 模拟登陆首先，根据班级通知群里给出的信息，需前往https://ehall.szpt.edu.cn/publicappinternet/sys/szptpubxsjkxxbs/\\*default/index.do，进行每日的信息填报。 进入了该地址，如未登录则会被重定向到https://authserver.szpt.edu.cn/authserver/login?service=https://ehall.szpt.edu.cn/publicappinternet/sys/szptpubxsjkxxbs/\\*default/index.do，要求登录。 进入该页面根据登录表单需求，共有7个参数 1234567usernamepasswordltdlltexecution_eventIdrmShown 其中发现有2个token参数 12ltexcution 则需要每次爬取该页面时，获取该token参数作为POST表单参数中 123# 获取登录参数lt = re.search('name=\"lt\" value=\"(.*?)\"/&gt;', html, re.S).group(1)execution = re.search('name=\"execution\" value=\"(.*?)\"/&gt;', html, re.S).group(1) 并且发现密码经过了前端加密上传，这时候则去寻找js部分。 从中js排除，发现有关加密的js文件为： 123aes.js (AES加密源码)encrypt.wisedu.js （AES加密逻辑模式）mobile-login_v1.0.js （登录） 从mobile-login_v1.0.js中找出加密部分 1234567891011121314...encryptPassword(password.value);//密码加密...//密码加密function encryptPassword(pwd0) &#123; try&#123; var pwd1 = encryptAES(pwd0,pwdDefaultEncryptSalt); getObj(\"mobilePasswordEncrypt\").value=pwd1; &#125;catch(e)&#123; getObj(\"mobilePasswordEncrypt\").value=pwd0; &#125;&#125;... 可发现它使用了AES加密。 高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥 AES加密逻辑 找出emcryptAES函数方法，encrypt.wisedu.js 文件 123456789101112131415161718192021222324252627282930313233//var aesKey = 'rjBFAaHsNkKAhpoi'; //密钥//AES-128-CBC加密模式，key需要为16位，key和iv可以一样function getAesString(data,key0,iv0)&#123;//加密 key0=key0.replace(/(^\\s+)|(\\s+$)/g, \"\"); var key = CryptoJS.enc.Utf8.parse(key0); var iv = CryptoJS.enc.Utf8.parse(iv0); var encrypted =CryptoJS.AES.encrypt(data,key, &#123; iv:iv, mode:CryptoJS.mode.CBC, padding:CryptoJS.pad.Pkcs7 &#125;); return encrypted.toString(); //返回的是base64格式的密文&#125;function encryptAES(data,aesKey)&#123; //加密 if(!aesKey)&#123; return data; &#125; var encrypted =getAesString(randomString(64)+data,aesKey,randomString(16)); //密文 return encrypted;&#125;var $aes_chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678';/****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/var aes_chars_len = $aes_chars.length;function randomString(len) &#123; var retStr = ''; for (i = 0; i &lt; len; i++) &#123; retStr += $aes_chars.charAt(Math.floor(Math.random() * aes_chars_len)); &#125; return retStr;&#125; 观察该文件，发现使用了AES-128的CBC加密模式，而密钥key长度是16位字符，加密结果返回的是base64字符串。既然知道了加密模式，则可以将此代码翻译成Python版即可。 1234567891011121314151617181920212223242526272829303132333435363738394041# AESclass AESCipher: def __init__(self, key): self.key = key[0:16].encode('utf-8') # 只截取16位 self.iv = self.random_string(16).encode() # 16位字符，用来填充缺失内容，可固定值也可随机字符串，具体选择看需求。 def __pad(self, text): \"\"\"填充方式，加密内容必须为16字节的倍数，若不足则使用self.iv进行填充\"\"\" text_length = len(text) amount_to_pad = AES.block_size - (text_length % AES.block_size) if amount_to_pad == 0: amount_to_pad = AES.block_size pad = chr(amount_to_pad) return text + pad * amount_to_pad def __unpad(self, text): pad = ord(text[-1]) return text[:-pad] def encrypt(self, text): \"\"\"加密\"\"\" raw = self.random_string(64) + text raw = self.__pad(raw).encode() cipher = AES.new(self.key, AES.MODE_CBC, self.iv) return base64.b64encode(cipher.encrypt(raw)) def decrypt(self, enc): \"\"\"解密\"\"\" enc = base64.b64decode(enc) cipher = AES.new(self.key, AES.MODE_CBC, self.iv) return self.__unpad(cipher.decrypt(enc).decode(\"utf-8\")) @staticmethod def random_string(length): aes_chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678' aes_chars_len = len(aes_chars) retStr = '' for i in range(0, length): retStr += aes_chars[math.floor(random.random() * aes_chars_len)] return retStr 有了加密逻辑并不行，AES上述讲了，高级加密标准为最常见的对称加密算法。对称加密算法也就是加密和解密用相同的密钥。那则还需要有加密盐（密钥），而密钥是基本上都是从服务端获取，可是从抓包中并没有发现有获取密钥的痕迹，则仔细观察了mobile-login.js中加密方法。 12345678910//密码加密function encryptPassword(pwd0) &#123; try&#123; var pwd1 = encryptAES(pwd0,pwdDefaultEncryptSalt); getObj(\"mobilePasswordEncrypt\").value=pwd1; &#125;catch(e)&#123; getObj(\"mobilePasswordEncrypt\").value=pwd0; &#125;&#125; 在观察后发现，pwd0为明文密码，pwd1为加密后密码，pwdDefaultEncryptSalt为加密盐，而加密盐是个变量。既然是个变量，那找遍所有文件总能获取到你（找了半天没找到），最终找到原来在网页源码中。 此刻有了加密盐，后面只剩下POST测试了。 123456789101112131415161718# 获取登录参数lt = re.search('name=\"lt\" value=\"(.*?)\"/&gt;', html, re.S).group(1)execution = re.search('name=\"execution\" value=\"(.*?)\"/&gt;', html, re.S).group(1)aes_key = re.search('pwdDefaultEncryptSalt = \"(.*?)\";', html, re.S).group(1)password_aes = pwdEncrypt(aes_key)# print(password_aes)params = &#123; 'username': username, 'password': password_aes, 'lt': lt, 'dllt': 'userNamePasswordLogin', 'execution': execution, '_eventId': 'submit', 'rmShown': '1'&#125; # 登录提交request = urllib.request.Request(url=POST_URL, data=urllib.parse.urlencode(params).encode(encoding='UTF-8'), method='POST')response = opener.open(request) 此时发现，登录就成功了。 Ehall 信息填报登录成功后，发现还是不能正常进入填报页面，会出现403拒绝访问错误，Ehell做了反爬虫检测，此时加上header User-Agent也无法进入，则猜测可能另set cookies。 开始往页面抓包，发现信息填报页返回了3个Cookies，而信息填报正需要该3个Cookies，在爬虫中并无发现有该3个Cookies，已经肯定了根据Cookies防止爬虫。 首先需要找到MOD_AUTH_CAS，那一切Cookies都解决了。 清楚cookie重新登录页面，发现了302重定向进入https://ehall.szpt.edu.cn/publicappinternet/sys/szptpubxsjkxxbs/\\*default/index.do?ticket=ST-65113-bLKuDKkv6Rg5LgHZoO0m1582649965403-G11l-cas 并且返回了一个新Cookie，这个MOD_AUTH_CAS则就是我们需要的。 但发现多了一个GET参数ticket，这个ticket又需要去寻找。 由于302重定向限制了获取重定向前获取到的信息，Python写多一项处理禁止302重定向。 12345# 禁止302重定向处理class NoRedirHandle(urllib.request.HTTPRedirectHandler): def http_error_302(self, req, fp, code, msg, headers): return fp http_error_301 = http_error_302 再重新登录，获取到了302重定向前的信息，其中则有ticket参数 有了ticket，那就能获取到MOD_AUTH_CAS了，与后面的3个新Cookies。 到后面以为有此3个Cookies就能获取到昨日填报的信息了，发现并不行，还是会报403错误，就开始找原因，最终发现前面获取到的_WEU与填报信息获取页请求的_WEU不一样，发现_WEU在某个页面读取完后更新了，再重新寻找。 一直排除Cookies变化，最终找到了https://ehall.szpt.edu.cn/publicappinternet/sys/itpub/MobileCommon/getMenuInfo.do，在请求完该页面后，_WEU发生了update。 发现请求该页面还需用户的APPID，APPNAME。 还是重复的步骤，最终在网页源码中找到这两个参数。 123# 获取js中的APPID与APPNAME参数APPID = re.search(\"APPID='(.*?)';\", html, re.S).group(1)APPNAME = re.search(\"APPNAME='(.*?)';\", html, re.S).group(1) 最终获取到新的_WEU，那后面也能获取到了你昨日填报的信息了。 最后再将此数据转变一下为https://ehall.szpt.edu.cn/publicappinternet/sys/szptpubxsjkxxbs/mrxxbs/saveReportInfo.do里的POST数据格式，再提交即可。 1234567# 提交信息params = &#123; 'formData': data[\"datas\"]&#125;request = urllib.request.Request(url=SAVE_INFO_POST_URL,data=urllib.parse.urlencode(params).encode(encoding='UTF-8'), method='POST', headers=header_getinfo)response = opener.open(request) 提交完成，今日份的填报就完成了。（后续也增加了队列定时任务版本）","categories":[],"tags":[]},{"title":"WePY小程序登录详解与配置","slug":"WePY小程序登录详解与配置","date":"2020-02-16T08:59:27.093Z","updated":"2020-02-16T08:57:48.308Z","comments":true,"path":"2020/02/16/WePY小程序登录详解与配置/","link":"","permalink":"http://yoursite.com/2020/02/16/WePY%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"","text":"小程序登录 - 时序图流程与OAuth2.0的授权码模式相似。 OAuth2.0 基本处理流程 得到授权码code 获取access_token 通过access_token，获取OpenID 通过access_token及OpenID调用API，获取用户授权信息 微信小程序登录处理流程 程序调用 wx.login() 接口获取临时登录凭证（code）（无需用户授权） 小程序提交 code 到服务器 服务器通过 appid、appsecret 和 code 请求微信接口，换取用户的 session_key 和 openid 服务器根据 openid 查找到对应的用户，存入 session_key ，然后为该用户生成 access_token （JWT）返回给小程序 用户拥有了 access_token ，小程序就可以调用需要身份认证的接口了 关于 session_key此处的 session_key 为存储在服务器中、用于获取用户信息等微信接口时所需的key。每次调用 wx.login() 之后，微信都会自动生成新的 session_key ，导致之前的 session_key 失效，所以在必要的时候 wx.login() ，而且还要及时保存 session_key 到服务器，以备后续使用。 代码调试 配置（基于Laravel）EasyWeChat回到 Laravel 项目中，我们需要调用微信的接口，加密解密微信接口数据，为了加快开发，使用 EasyWeChat 进行开发，EasyWeChat已经封装好了微信相关的接口。 可以直接使用 EasyWeChat Laravel 5 的拓展包: overtrue/laravel-wechat。安装引入拓展包： 12$ cd ~&#x2F;Code&#x2F;LaravelProject$ composer require &quot;overtrue&#x2F;laravel-wechat:~4.0&quot; Laravel 配置发布配置文件： 1$ php artisan vendor:publish --provider&#x3D;&quot;Overtrue\\LaravelWeChat\\ServiceProvider&quot; 修改配置文件，将小程序部分的注释打开： config/wechat.php 1234567891011&#x2F;* * 小程序 *&#x2F;&#39;mini_program&#39; &#x3D;&gt; [ &#39;default&#39; &#x3D;&gt; [ &#39;app_id&#39; &#x3D;&gt; env(&#39;WECHAT_MINI_PROGRAM_APPID&#39;, &#39;&#39;), &#39;secret&#39; &#x3D;&gt; env(&#39;WECHAT_MINI_PROGRAM_SECRET&#39;, &#39;&#39;), &#39;token&#39; &#x3D;&gt; env(&#39;WECHAT_MINI_PROGRAM_TOKEN&#39;, &#39;&#39;), &#39;aes_key&#39; &#x3D;&gt; env(&#39;WECHAT_MINI_PROGRAM_AES_KEY&#39;, &#39;&#39;), ],], 登录 微信公众平台，获取小程序 AppID 和 AppSecret 编辑 .env 配置文件，增加参数AppID、AppSecret: 123# 小程序WECHAT_MINI_PROGRAM_APPID&#x3D;wx756787de07****WECHAT_MINI_PROGRAM_SECRET&#x3D;bb28893cc9cdb3e0f********* WePY 中 Promise 安装后面代码使用了Promise对象。根据wepy项目中使用Promise。 在1.4.1以下版本，wepy生成的项目默认都会加入promise polyfill。 在1.4.1以后的版本，需要用户手动加入。 在WePY项目中： 123$ yarn add promise-polyfill&#x2F;&#x2F; 在windws环境下要加上--no-bin-links&gt; yarn add promise-polyfill --no-bin-links 增加 this.use(‘promisify’); 使 API promise 化： src/app.wpy 1234constructor () &#123; super() this.use(&#39;requestfix&#39;) this.use(&#39;promisify&#39;) 小程序获取 Code在小程序中调用 wepy.login() 接口，获取 Code src/app.wpy 12345onLaunch() &#123; wepy.login().then(res &#x3D;&gt; &#123; console.log(&#39;login: &#39;, res) &#125;)&#125; 由于我们使用了 WePY 框架，所有小程序的接口都需要使用 wepy 对象调用，例如 wx.login() 就需要使用 wepy.login()。 进行编译，在微信开发者工具 - Console 则可以看到code信息。 服务器获取 OpenID用 tinker 进行调试： 1234$ cd ~&#x2F;Code&#x2F;LaravelProject$ php artisan tinker&gt;&gt;&gt; $miniProgram &#x3D; \\EasyWeChat::miniProgram();&gt;&gt;&gt; $miniProgram-&gt;auth-&gt;session(&#39;CODE&#39;); &#x2F;&#x2F; 此处CODE为WePY获取到的code 获取 UnionID关于UnionID 在以上返回信息如拥有UnionID情况，则无须用户再次授权： 如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号。开发者可以直接通过 wx.login 获取到该用户 UnionID，无须用户再次授权。 如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。开发者也可以直接通过 wx.login 获取到该用户 UnionID，无须用户再次授权。 对于UnionID的限制条件： 该小程序项目成立前，已有对应的网站，并且已拥有用户。 网站已有API，用户可通过账号或微信登录。 UnionID创建UnionID的获取需服务号通过微信认证 在微信公众平台 - 开发 - 接口权限 - 网页授权获取用户基本信息 中设置回调页面域名，在用户授权同意给公众号后，会将该用户的unionID传入该域名。（正式公众号回调地址需为域名）","categories":[],"tags":[]},{"title":"WePY初始化","slug":"WePY初始化","date":"2020-02-16T08:59:12.641Z","updated":"2020-02-15T17:09:11.317Z","comments":true,"path":"2020/02/16/WePY初始化/","link":"","permalink":"http://yoursite.com/2020/02/16/WePY%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"WePYWePY官方文档 安装 wepy-cli首先需要全局安装 wepy-cli： 123$ sudo yarn global add wepy-cli// 在windws环境下要加上--no-bin-links&gt; yarn global add wepy-cli --no-bin-links 安装成功，通过命令 wepy -v 可以查看到目前版本 初始化项目123456789$ wepy init standard .&#x2F;weapp_project? Yes &#x2F;&#x2F; 目标文件已存在，是否继续? weapp_project &#x2F;&#x2F; 填写你的项目名? wx63452****** &#x2F;&#x2F; 填写你的AppID? weapp laravel project &#x2F;&#x2F; 填写你的项目描述? AtmosphereMao@gmail.com &#x2F;&#x2F; 开发者? Yes &#x2F;&#x2F; 使用Eslint? Yes &#x2F;&#x2F; 使用Redux? Yes &#x2F;&#x2F; 使用Web转换功能 WePY 结构 文件夹名称 类型 简介 dist 目录 存放编译后的文件 src 目录 源码文件 src/app.wpy 目录 项目入口文件 src/pages 目录 存放小程序页面 src/components 目录 存放小程序组件 src/mixins 目录 存放 Mixin 文件 node_modules 目录 NPM 依赖模块 src/index.template.html 文件 模板页面 html wepy.config.js 文件 全局配置文件 yarn.lock 文件 依赖列表，确保这个应用的副本使用相同版本的依赖 package.json 文件 项目的 package 配置 project.config.json 文件 开发者工具配置 .wepyignore 文件 WePY 忽略的文件 .wepycache 文件 WePY 缓存文件，防止在 build 时，重复 build npm 目录 .prettierrc 文件 prettier 配置文件 .eslintrc.js 文件 eslint 配置文件 .eslintignore 文件 eslint 忽略的文件 .editorconfig 文件 编辑器配置文件 安装依赖包WePY 依赖于很多 node 包，接下来执行 yarn 安装这些包 123$ yarn install&#x2F;&#x2F; 同上，windows需加--no-bin-links&gt; yarn install --no-bin-links 编译最后对项目进行编译，并持续监听代码变化： 1234$ wepy build --watch&#x2F;&#x2F; 如在homestead虚拟机环境下运行，会出现检测不到文件变化的情况or$ npm run dev 微信开发者工具调试经过编译，可在微信开发者工具上看到小程序界面，查看项目 详情： dist 目录就是编译好的文件目录，点击右上角的 详情，可以看到开发者工具已经适配好 WePY 框架 默认将 ES6 转 ES5 上传代码时样式自动补全 代码上传时自动压缩 该三个选项关闭，这里一定不要勾选这三个选项，否则调试的时候会报错。","categories":[],"tags":[]},{"title":"Laravel生产环境配置","slug":"Laravel生产环境配置","date":"2020-02-05T05:41:21.786Z","updated":"2020-02-03T17:29:51.268Z","comments":true,"path":"2020/02/05/Laravel生产环境配置/","link":"","permalink":"http://yoursite.com/2020/02/05/Laravel%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"允许使用的顶级域名视图View设置123@if (app()-&gt;isLocal()) @include(&#39;sudosu::user-selector&#39;)@endif Config设置config/sudosu.php 1234567return [ &#x2F;&#x2F; 允许使用的顶级域名 &#39;allowed_tlds&#39; &#x3D;&gt; [&#39;dev&#39;, &#39;local&#39;, &#39;test&#39;, &#39;app&#39;], &#x2F;&#x2F; 用户模型 &#39;user_model&#39; &#x3D;&gt; App\\Models\\User::class]; .env生产环境中设置 1APP_ENV&#x3D;local 说明现在是本地环境，而不是生产环境。app ()-&gt;isLocal () 判断是本地环境才去注册 SudoSo。日后产品上线了，可以在.env 里改为： 1APP_ENV&#x3D;production 这样 isLocal () 返回 false, 生产环境里就不会引入 SudoSo 了。","categories":[],"tags":[]},{"title":"Homestead搭建与配置","slug":"Homestead搭建与配置","date":"2020-02-05T05:40:50.025Z","updated":"2020-02-03T17:50:12.454Z","comments":true,"path":"2020/02/05/Homestead搭建与配置/","link":"","permalink":"http://yoursite.com/2020/02/05/Homestead%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"","text":"准备 第一步，安装虚拟机VirtualBox 第二 步，下载vagrant 第三步，安装完毕vagrant之后，运行1vagrant box add laravel&#x2F;homestead 此步的下载会很慢，根据上面提示的地址，用迅雷或其他下载软件下载，保证下载不会被中断，下载完成后，用以下代码完成安装1vagrant box add laravel&#x2F;homestead homestead.box 如使用该方法完成安装，则需要更改版本号（默认导入box版本号为0） 打开C:\\Users\\M.vagrant.d\\boxes，更改box里的版本号为对应的版本。 第四步，把homestead克隆到本地 1git clone https:&#x2F;&#x2F;github.com&#x2F;laravel&#x2F;homestead.git ~&#x2F;Homestead 此时我们举例homestead下载到了~/Homestead文件下面 第五步，创建Homestead.yaml配置文件 12345cd ~&#x2F;Homestead&#x2F;&#x2F; Mac &#x2F; Linux...bash init.sh&#x2F;&#x2F; Windows...init.bat 此时会生成一个Homestead.yaml文件就是配置文件 Homestead.yaml 配置 虚拟机设置 Homestead 支持我们对虚拟机的IP，内存，CPU，虚拟机的默认提供者进行配置。这里我们基本不需要做任何配置，因此可以跳过。 1234ip: &quot;192.168.10.10&quot;memory: 2048cpus: 1provider: virtualbox SSH 秘钥登录配置 authorize 选项是指派登录虚拟机授权连接的公钥文件，此文件填写的是主机上的公钥文件地址，虚拟机初始化时，此文件里的内容会被复制存储到虚拟机的/home/vagrant/.ssh/authorized_keys 文件中，从而实现 SSH免密码登录。在这里我们默认填写即可。 1authorize: ~&#x2F;.ssh&#x2F;id_rsa.pub keys 是数组选项，填写的是本机的 SSH私钥文件地址。虚拟机初始化时，会将此处填写的所有 SSH 私钥文件复制到虚拟机的 /home/vagrant/.ssh/ 文件夹中，从而使虚拟机能共享主机上的 SSH 私钥文件，使虚拟机具备等同于主机的身份认证。此功能为 SSH 授权提供了便利，例如在后面章节中，我们只需要在 GitHub 上配置一个 SSH 公钥，即可实现 GitHub 对虚拟机和主机共同认证。 此处我们将公钥和私钥一起同步到虚拟机中： 123keys: - ~&#x2F;.ssh&#x2F;id_rsa - ~&#x2F;.ssh&#x2F;id_rsa.pub 共享文件夹配置 我们可以通过 folders 来指明本机要映射到 Homestead 虚拟机上的文件夹。 map 对应的是我们本机的文件夹，格式例如：E：/Homestead/Code，以开发者实际项目目录为准。 to 对应的是 Homestead 上的文件夹。 123folders: - map: ~&#x2F;Code to: &#x2F;home&#x2F;vagrant&#x2F;Code 站点配置站点配置允许你在主机里，通过域名来访问虚拟机里的 Laravel 应用。如下面 sites 配置所示，将 homestead.test 映射到一个 Laravel 项目的 public 目录上。这一行配置，会命令 Homestead 为我们新建一个 Nginx 站点，并且把 Web Root 配置到指定目录下。Laravel 应用的 Nginx 站点 Web Root 配置，默认就是在根目录下的 public 目录。 123sites: - map: homestead.test to: &#x2F;home&#x2F;vagrant&#x2F;Code&#x2F;Laravel&#x2F;public 此处的laravle文件并不存在，需要在对应创建 1~&#x2F;Code&#x2F;Laravel&#x2F;public 根据上面站点地址，如需本地测试，则hosts也需要修改C:\\Windows\\System32\\Drivers\\etc\\hosts 1192.168.10.10 homestead.test 数据库配置 我们可以为 Homestead 指定数据库名称，这里使用默认设置即可。 12databases: - homestead 自定义变量 最后，如果你需要自定义一些在虚拟机上可以使用的自定义变量，则可以在 variables 中进行定义。 123variables: - key: APP_ENV value: local 运行 Vagrant完成了 Homestead 的配置，接下来我们要开始启动虚拟机了。 在命令中输入 1vagrant 能看到 Vagrant 为我们提供了一些便利的命令行，下面简单介绍一下 Vagrant 常用的一些命令行的使用： 命令行 说明 vagrant init 初始化 vagrant vagrant up 启动 vagrant vagrant halt 关闭 vagrant vagrant ssh 通过 SSH 登录 vagrant（需要先启动 vagrant） vagrant provision 重新应用更改 vagrant 配置 vagrant destroy 删除 vagrant 让我们开始启动 Homestead： 1&gt; cd ~&#x2F;Homestead &amp;&amp; vagrant up 第一次启动时，Vagrant 会做以下这几件事情： 以导入的 Homestead 虚拟机盒子为模板，新建一台虚拟机； 并按照 Homestead.yaml 里的配置信息，对这台新建的虚拟机进行配置； 配置完成后启动虚拟机。 成功启动后，还是在 ~/Homestead 目录中，通过以下命令来 SSH 登录 Homestead 虚拟机中： 1&gt; vagrant ssh 在虚拟机界面下可以输入退出虚拟机： 1$ exit 最后尝试关闭 Homestead： 1&gt; vagrant halt","categories":[],"tags":[]},{"title":"Hexo 博客创建成功","slug":"myfirstpost","date":"2019-12-12T09:55:09.360Z","updated":"2019-12-14T16:06:05.828Z","comments":true,"path":"2019/12/12/myfirstpost/","link":"","permalink":"http://yoursite.com/2019/12/12/myfirstpost/","excerpt":"","text":"欢迎来到我的Blog，我的blog之后会记录生活乐趣与在编程生涯中遇到的各种问题。 请大家多多指教。","categories":[],"tags":[]}]}